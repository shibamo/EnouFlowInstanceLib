using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EnouFlowInstanceLib
{
  public enum EnumFlowActionRequestType
  {
    take = 1,             // 用户接办该活动, 如果该活动有其他用户,则将这些用户的任务标记为EnumFlowTaskState.obsoleted
    moveTo,               // 正常处理到下一个活动
    start,                // 启动流程实例
    moveToAutoGenerated,  // 由引擎根据自动活动的规则集执行结果生成
    inviteOther,          // 请求任意其它人/角色的特殊Action(提供Approve,Reject,...的建议), = More Approval Dynamically, 但不会影响当前活动taker对流程实例的继续执行
    //feedBackOfInvite,     // 对inviteOther的答复
    inviteOtherFeedback,  // 对inviteOther的回应
    rejectToStart,        // 退回至起始状态并把任务指定给当初的启动用户
    rejectToPrevManual,   // 退回至上一个人工状态节点的当初经办用户
    revokeTake,           // 撤回接办行为
    terminate,            // 直接终止该流程实例
    impersonate,          // 代办

    restartTo,            // 重启已结束的流程实例到指定活动
    holdUntil,            // 主动挂起等待(相对其它被动等待的实例将不会提醒)
    clawback,             // 追回已被处理完的实例,使其重新回到该办理人已接办状态
    jumpTo,               // 跳转到其它任意活动
    takeover,             // 强行接管,此时其它用户已接办
    urge,                 // 催办
    adjustFlowTemplate    // 调整使用指定的流程模板继续运行
  }

  public enum EnumFlowInstanceProcessingState
  {
    backgroundProcessing = 1,   // 流程引擎正在根据传入的FlowActionRequest进行处理
    waitingActionRequest,       // 等待接受处理请求(即使正在等待invitee的处理)
    stopped,                    // 已结束
  }

  public enum EnumFlowInstanceLifeState
  {
    start = 1,  // 开始状态
    middle,     // 任意中间的活动处理
    end,        // 结束状态
  }

  public enum EnumFlowTaskType
  {
    normal = 1,
    invitation,
    delegation,
    redraft
  }

  public enum EnumFlowTaskState
  {
    initial = 1,
    peeked,
    taken,
    done,
    deletedByUser,
    obsoleted,
  }

  public enum EnumFlowTaskNotifyState
  {
    initial = 1,
    inProgress,
    notified,
  }

  public enum EnumFlowActionRequestResultType
  {
    notAvailable = 1,
    success =2,
    fail = 3
  }
}
